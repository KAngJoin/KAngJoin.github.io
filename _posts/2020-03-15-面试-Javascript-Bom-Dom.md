---
layout: post
title: 面试——Javascript（ES系列）+DOM+BOM（持续更新...）
subtitle: 总结梳理知识点，温故知新
date: 2020-03-20
author: dukang
header-img: img/wall.jpg
catalog: true
tags: 
    - 面试
---

# Ⅰ、JavaScript

### == 和 === 的区别

`==`	先比较类型，类型不同先进行类型转换；再比较值；

`===` 先比较类型，不同则返回false；类型相同才比较值。

### Map和Set的区别

# Ⅱ、DOM

### 浏览器组成

1. 内核

   - 渲染引擎GUI
   - JS引擎

   **二者互斥**

2. 外壳

| 主流浏览器   | 内核（渲染引擎）               | Js引擎                                     |
| ------- | ---------------------- | ---------------------------------------- |
| IE/Edge | trident-->EdgeHTML(分支) | JScript（IE3.0-IE8.0） / Chakra（IE9+之后）    |
| Chrome  | webkit-->blink(分支)     | V8                                       |
| Safari  | webkit                 | Nitro（4-）                                |
| Opera   | Presto->blink          | SpiderMonkey（1.0-3.0）/ TraceMonkey（3.5-3.6）/ JaegerMonkey（4.0-） |
| Firefox | Gecko                  | Linear A（4.0-6.1）/ Linear B（7.0-9.2）/ Futhark（9.5-10.2）/ Carakan（10.5-） |

### 客户端存储（cookie、localStorage、sessionStorage）

1. **[Cookie](https://www.nowcoder.com/ta/front-end-interview/review?tpId=10&tqId=11077&query=&asc=true&order=&page=1)**

   **限制**

   - 大多数浏览器支持最大为4096字节（4kb）的Cookie；
   - 浏览器还会限制站点可以在用户计算机上存储的Cookie数量，大部分浏览器只允许每个站点存储20个Cookie。若试图存储更多的Cookie，则最老的Cookie便会被删除；
   - 部分浏览器会对所有站点的Cookie总数作出绝对限制，一般为300 个；
   - 默认情况下，Cookie会随着Http请求发送到后台服务器，可是并不是所有请求都需要Cookie，如：js、css、图片等

2. **会话级别的 sessionStorage**  （对象）

   会话级别：与浏览器当前会话相关，页面关闭，数据会自动消除。

   操作方法：

   - setItem(key,value)：添加本地存储数据；
   - getItem(key)：通过key获取相应的Value；
   - removeItem(key)：通过key删除本地数据；
   - clear()：清空数据。

3. **永久性的 localStorage ** （对象）

   数据不会随着Http 请求发送到后台服务器;

   存储数据的大小几乎不用考虑，HTML5的标准中要求浏览器至少要支持到**4MB**;

   **操作方法：同上**

> **注意**：浏览器获取ocal storage 和session storage 的值为<u>字符串类型</u>。

### [从输入URL到页面展示的过程](https://juejin.im/post/5c773dd251882519610194c1)

1. **URL解析**：首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作。

2. **DNS查询**：浏览器缓存->操作系统缓存->路由器缓存->ISP DNS缓存->根域名服务器查询

3. **TCP连接**：按我课本中TCP/IP网络模型来说

   1.应用层：发起http请求

   ```
   请求报头(Headers),请求方法,目标地址、遵循协议
   请求body
   ```

   2.传输层：TCP报文传输（TCP三次握手的建立）
   3.网络层：IP协议查询Mac地址
   4.链路层：以太网协议
   在发送请求时从应用层层层包裹数据，每一层都要对数据进行封装。

4. **处理请求**：接受 TCP 报文后，会对连接进行处理，对HTTP协议进行解析（请求方法、域名、路径等），并且进行一些验证。

5. **接受响应**：浏览器接收到来自服务器的响应资源后，会对资源进行分析。首先查看 Response header，根据不同状态码做不同的事（比如上面提到的重定向）

6. **渲染页面**：不同的浏览器内核，渲染过程也不完全相同。

### 浏览器如何解析渲染网页的？

#### 1. 根据 HTML 解析 DOM 树

- 根据 HTML 的内容，将标签按照结构解析成为 DOM 树，DOM 树解析的过程是一个深度优先遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点。
- 在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕。

#### 2. 根据 CSS 解析生成 CSS 规则树

- 解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪。
- 浏览器在 CSS 规则树生成之前不会进行渲染。

#### 3. 结合 DOM 树和 CSS 规则树，生成渲染树

- DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树。
- 精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度。

#### 4. 根据渲染树计算每一个节点的信息（布局）

- 布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸
- 回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。

#### 5. 根据计算好的信息绘制页面

- 绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。
- 重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。
- 回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。

#### 何时触发回流和重绘

何时发生回流：

- 添加或删除可见的DOM元素
- 元素的位置发生变化
- 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）
- 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。
- 页面一开始渲染的时候（这肯定避免不了）
- 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）

何时发生重绘（回流一定会触发重绘）：

当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。

有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。现代浏览器会对频繁的回流或重绘操作进行优化，浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。你访问以下属性或方法时，浏览器会立刻清空队列：

- `clientWidth`、`clientHeight`、`clientTop`、`clientLeft`
- `offsetWidth`、`offsetHeight`、`offsetTop`、`offsetLeft`
- `scrollWidth`、`scrollHeight`、`scrollTop`、`scrollLeft`
- `width`、`height`
- `getComputedStyle()`
- `getBoundingClientRect()`

以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，**最好避免使用上面列出的属性，他们都会刷新渲染队列。**如果要使用它们，最好将值缓存起来。

#### 如何避免触发回流和重绘

CSS：

- 避免使用table布局。
- 尽可能在DOM树的最末端改变class。
- 避免设置多层内联样式。
- 将动画效果应用到`position`属性为`absolute`或`fixed`的元素上
- 避免使用CSS表达式（例如：`calc()`）
- CSS3硬件加速（GPU加速）

JavaScript：

- 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性
- 避免频繁操作DOM，创建一个`documentFragment`，在它上面应用所有DOM操作，最后再把它添加到文档中
- 也可以先为元素设置`display: none`，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘
- 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来
- 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流