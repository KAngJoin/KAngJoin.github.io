---
layout: post
title: Vue高级实战技巧
subtitle: 提高开发效率
date: 2020-03-24
author: dukang
header-img: img/vue-bg.jpg
catalog: true
tags: 
    - Vue
---

### 全局组件注册

###### 过去式

正常引用组件，先使用`import ... from ...` 语法引入，然后 `components`注册即可。

```vue
<template>
<div class="hello">
  <h1>{{ msg }}</h1>
  <child1 :text="text"></child1> <!-- 【3】-->
  </div>
</template>

<script>
  import child1 from "./component/child.vue"; // 【1】
  export default {
    name: "HelloWorld",
    props: {
      msg: String
    },
    data() {
      return {
        text: "HelloWord"
      };
    },
    components: { // 【2】
      child1
    }
  };
</script>

<style scoped lang='scss'>
</style>
```

这样做对于高频组件（一般理解为大于两次引用的组件就是高频组件）来说，相当的不友好。

###### 现在

在你阅读下面内容之前，你需要准备的知识：[webpack-管理依赖](https://webpack.docschina.org/guides/dependency-management/#require-context) 、[Vue.use()](https://vuejs.bootcss.com/api/#Vue-use) 、[Vue.component()](https://vuejs.bootcss.com/api/#Vue-component)

- index.js（获取高频组件，处理并全局注册）

```javascript
//获取高频组件
const requireComponent = require.context('./', false, /\.vue$/)
// 首字母大写，vue组件命名通常都是首字母大写的。
function changeStr(str) { return str.charAt(0).toUpperCase() + str.slice(1) }
const install = (Vue) => {
  //  requireComponent.keys() 高频组件数组
  requireComponent.keys().forEach(fileName => {
    let vueTemplete = requireComponent(fileName);
    //获取到高频组件的名词
    let componentName = changeStr(fileName.replace(/\.\//, '').replace(/\.\w+$/, ''))
    Vue.component(componentName, vueTemplete.default || vueTemplete)
  });
}
export default { install }
```

- main.js

```javascript
// ... 
// 引入模块
import globalTemplate from './components/component/index'
//全局注册
Vue.use(globalTemplate)
// ...
```

- parent.vue

```vue
<template>
<div class="hello">
  <child :text="text"></child>
  <child2 :text="text"></child2>
  <child1 :text="text"></child1>
  <child3 :text="text"></child3>
  </div>
</template>

<script>
  // import child1 from "./component/child.vue"; 无需引用
  export default {
    name: "Parent",
    data() {
      return {
        text: "HelloWord"
      };
    }
    // components: { 无需注册
    //   child1
    // }
  };
</script>
<style scoped lang='scss'>
</style>
```

- 子组件

所有的子组件（高频组件），正常编写即可。

### 权限控制（自定义指令）

你是否还是使用`display:none` 控制权限按钮的显示，或者使用`v-if/v-else` 。

现在你可以尝试使用[`vue-自定义指令`](https://vuejs.bootcss.com/guide/custom-directive.html)

思考，后台如何传对应的权限给你？（数组）。下面我们模拟一个后台返回的数据。

- array.js（检查是否有权限）

 ```js
export function checkArr(key) {
  let arr = ['101', '211', '302', '404', 'other']; // 后端返回的权限数组
  const hasIndex = arr.indexOf(key)
  return hasIndex > -1 ? true : false
}
 ```

- main.js

```js
// ... 
import { checkArr } from './common/array'
Vue.directive('display-key', {
  inserted(el, binding) {
    // 元素上绑定的值，如 <input v-bind:value = '1' />
    let displayKey = binding.value;
    if (displayKey) {
      let permission = checkArr(displayKey);
      //无权限则不显示
      if (!permission) {
        el.parentNode && el.parentNode.removeChild(el)
      }
    } else {
      // 抛出异常
      throw new Error(`你需要设置一个指令！如：v-display-key="'2'"`)
    }
  }
})
// ... 
```

- 组件使用

```vue
<template>
<div>
  <button v-display-key="'2111'">支付</button> <!-- 不会显示 -->
  </div>
</template>
<!-- 其它内容 -->
```

### 主路由动态引入

我们在实际开发中，业务往往都是分模块，分功能的。比如，登录、课程、作业、商品列表等，像这样的情况我们就需要`业务分层`。那么`VueRouter` 就需要根据分层进行模块管理。

###### 过去式

- router > index.js

```javascript
import Vue from 'vue'
import vueRouter from 'vue-router'
// 引入组件模块
import Home from '../views/Home.vue'
import Login from '../views/Login.vue'
Vue.use(vueRouter)

const routes = [
  {
    path: '/',
    name: 'Home',
    component: Home
  },
  {
    path: '/login',
    name: 'Login',
    component: Login
  }
  // a lot of
]
export const router = new vueRouter({ routes: routes })
```

- main.js

```javascript
// .. 
import { router } from './router/index';
// ..
new Vue({
+ router: router,
  render: h => h(App),
}).$mount('#app')
```

这样的问题在于，业务庞大时 ，代码密集，不好维护 。

###### 现在

将所有的路由按业务分层，放入新建文件夹route下，并以 `.routes.js` 结尾命名，如 `login.routes.js` 

- route > login.routes.js（单独的业务模块需要的所有路由，每一个模块为一个js文件）

```js
export default {
  path: '/login',
  name: 'Login',
  component: () => import('../views/Login.vue')
  // a lot of
}
```

- router > index.js

```js
import Vue from 'vue'
import vueRouter from 'vue-router'
Vue.use(vueRouter)

// 下面的内容，重点注意
const routerList = [];
function importAll(req) {
  req.keys().forEach((key) => {
    routerList.push(req(key).default)
    // 这里的default就是export default 的 default
  });
}
importAll(require.context('../route', true, /\.routes\.js$/))

const routes = [
  {
    path: '/',
    name: 'Class',
    component: () => import('../views/Class.vue')
  },
  ...routerList, // 拓展符
]

export const router = new vueRouter({ routes: routes })
```

这种做法，你需要注意的是，route文件下的文件命名必须按照` /\.routes\.js$/`匹配。

###### [路由懒加载](https://router.vuejs.org/zh/guide/advanced/lazy-loading.html#%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD)

### [render](https://cn.vuejs.org/v2/api/#render)函数

###### 过去式

使用`v-if` ` v-else-if` ` v-else` 判断，然后显示后触发不同事件。针对只有两种情况是可以这么做，但是很多种情况怎么办啦?

- render.vue

```vue
<template>
  <div>
    <h1>my name is rendr page</h1>
    <button @click="clickEvent(1)" v-if="num === 1">click-1</button>
    <button @click="clickEvent(2)" v-else-if="num === 2">click-2</button>
    <button @click="clickEvent(3)" v-else>click-3</button>
  </div>
</template>

<script>
export default {
  name: "Render",
  data() {
    return {
      num: 1
    };
  },
  methods: {
    clickEvent(param) {
      alert(param);
    }
  }
};
</script>
<style lang="scss" scoped>
</style>
```

###### 现在

我们的做法，是采用vue提供的render函数，编写组件。

- render.vue

```vue
<template>
<div>
  <h1>my name is rendr page</h1>
  <Button :type="'success'" :text="'提交'" @clickEvent="handerClick"></Button>
  </div>
</template>
<script>
  import Button from "../components/render/button.vue";
  export default {
    name: "Render",
    components: { Button },
    methods: {
      handerClick() {
        alert(1);
      }
    }
  };
</script>
<style lang="scss" scoped>
</style>
```

少了组件判断

- button.vue （render）

```vue
<script>
  export default {
    props: {
      type: {
        type: String,
        default: "normal"
      },
      text: {
        type: String,
        default: "Click Me"
      }
    },
    render(h) {
      return h("button", {
        // v-bind:css
        class: {
          btn: true,
          "btn-success": this.type === "success",
          "btn-danger": this.type === "danger",
          "btn-warning": this.type === "warning",
          normal: !this.type
        },
        // dom操作
        domProps: {
          innerText: this.text
        },
        on: {
          click: this.handleClick
        }
      });
    },
    methods: {
      handleClick() {
        this.$emit("clickEvent" );
      }
    }
  };
</script>

<style scoped>
  .btn {
    width: 80px;
    height: 40px;
    text-align: center;
    line-height: 40px;
    color: #fff;
    background: #ccc;
  }
  .btn-success {
    background: green;
  }
  .btn-danger {
    background: red;
  }
  .btn-warning {
    background: orange;
  }
</style>
```

###### QA

> Q：vue已经有了`template`，为什么还要`render`函数？
>
> A：弥补template的不足。

> Q：template和render函数的应用场景？区别？
>
> A：
>
> 相同之处：
>
> `render 函数` 跟 `template` 一样都是创建 html 模板。
>
> 不同之处：
>
> - Template适合逻辑简单，render适合复杂逻辑。
>
>
> - 使用者template理解起来相对容易，但灵活性不足；自定义render函数灵活性高，但对使用者要求较高。
>
>
> - render的性能较高，template性能较低。这一点我们可以看一下，下图中vue组件渲染的流程图可知。
>
>
> - 使用render函数渲染没有编译过程，相当于使用者直接将代码给程序。所以，使用它对使用者要求高，且易出现错误
>
>
> - Render 函数的优先级要比template的级别要高，但是要注意的是Mustache(双花括号)语法就不能再次使用
> - template会转义为vNode，而render免去转义过程，

### 你不一定需要Vuex

###### Vuex的替代方案

- bus
- 简易store